# 스프링 핵심 원리 - 기본편
## 7. 의존관계 자동 주입
### 1) 다양한 의존관계 주입 방법
- 생성자 주입
    - 생성자 호출시점에 딱 한 번만 호출되기 때문에 **불변**, **필수** 의존관계에 사용된다
    - 생성자가 하나만 있으면, `@Autowired`를 생략할 수 있다
    - ❗[TIP 6] 좋은 아키텍트는 제약, 한계가 있는 것이다
- 수정자(setter) 주입
    - **선택**, **변경가능성**이 있는 의존관계에 사용된다
    - ❓[자바빈 프로퍼티에 대해 더 알아보았다]()
- 필드 주입
    - 외부에서 변경이 불가능하여 테스트 하기가 힘들다는 단점이 있다. 그래서 DI 프레임워크가 없으면 아무것도 할 수 없다. 그러므로 사용을 지양하자.
    - 그러나 테스트 코드 혹은 @Configuration 같은 애플리케이션 코드가 아닌 곳에서는 사용할 수 있다
- 일반 메서드 주입
    - 한 번에 여러 필드를 주입받을 수 있지만, 잘 사용되지 않는다. 생성자나 수정자 주입으로 대체할 수 있기 때문이다.
### 2) 옵션 처리
- 주입할 스프링 빈이 없는 경우의 `@Autowired` 사용법
    - `@Autowired(required=false)`를 활용한 메소드 동적 호출
    - 파라메터에 `@Nullable`를 활용하여 null 입력
    - 파라메터에 `Optional<>`를 활용하여 Optional.empty 입력
### 3) 생성자 주입을 선택해라!
- **불변**
    - 의존관계 주입은 애플리케이션 종료까지 불변해야 한다. 그래서 public인 수정자 주입은 좋은 설계가 아니다.
      필드 주입은 외부 변경이 불가하여 애플리케이션이 딱딱해지기 때문에 역시 좋은 설계가 아니다.
- 생성자 주입 사용시, 필드에 `final` 키워드를 붙여주면 생성자에서 값이 설정되지 않는 경우 컴파일 오류를 내준다
- ❗[TIP 7] 컴파일 오류가 가장 좋은 오류다. 그러므로, 컴파일 오류가 나도록 설계하는 것이 좋다
### 4) 롬복과 최신 트랜드
- Lombok 라이브러리 적용
- `@RequiredArgsConstructor`를 사용한 final 필드 생성자 자동 생성
### 5) 조회 빈이 2개 이상 - 문제
- `@Autowired`는 스프링 빈을 타입으로 조회한다. 그래서 등록된 같은 타입의 빈이 2개 이상이면, NoUniqueBeanDefinitionException이 발생한다.
  하위 구현체를 지정하는 방법은 DIP를 위반하기 때문에 다른 방법을 찾아야 한다
### 6) @Autowired 필드 명, @Qualifier, @Primary
- @Autowired 필드명 매칭
    - 타입 매칭의 결과가 2개 이상일 때, 필드 명, 파라미터 명으로 이름 매칭
- @Qualifier 사용
    - @Qualifier 끼리 매칭
    - Bean 이름 매칭
- @Primary 사용
- ❗[TIP 8] 스프링은 자동보다는 수동이, 넓은 범위보다는 좁은 범위의 선택권이 우선 순위가 높다
### 7) 애노테이션 직접 만들기
- `@Qualifier`를 상속받는 `@MainDiscountPolicy` 애노테이션 생성
- 단, 애노테이션 상속은 자바의 기능은 아니고, 스프링의 기능이다
### 8) 조회 빈이 모두 필요할 때, List, Map
- Map, List를 사용하여 특정 추상체의 구현체 빈을 모두 주입받아 저장하기
- ❓신기하게도 Map<String, DiscountPolicy>를 적었더니, 알아서 잘 들어왔다. 모든 자료형에 스프링이 타입만 보고 알아서 넣어주는 걸까?
    - 모든 자료형에 지원되는 것은 아니고, 자바 컬렉션 인터페이스만 제공한다
### 9) 자동, 수동의 올바른 실무 운영 기준
- 편리한 자동 기능을 기본으로 사용하자
- ❓ 그럼 수동 빈 등록은 언제 쓸까?
    - 기술 지원 로직일 경우에 사용
        - 애플리케이션에 광범위하게 영향을 미치기 때문에 가시적으로 나타나게 하는 것이 더 좋다
    - 다형성을 적극적으로 활용하는 비즈니스 로직에 사용
        - [의존관계 자동 주입 - 조회한 빈이 모두 필요할 때, List, Map] 을 보면, 어디서 어떤 빈들이 주입되는지 한 눈에 파악하기가 어렵다.
          이런 경우, 별도의 설정 정보를 만들어 수동으로 등록하거나, 자동으로 특정 패키지에라도 묶어두는 것이 추후 유지보수에 좋다

## 8. 빈 생명주기 콜백
### 1) 빈 생명주기 콜백 시작
- 빈 생명주기 콜백이란, 애플리케이션의 시작 시점 혹은 종료 시점에 필요한 연결 및 종료 처리를 할 수 있게끔 알려주는 것
    - ❓ 데이터 커넥션 풀이란
        - 퍼포먼스를 위해 애플리케이션 서버와 DB간의 연결을 미리 잡아두는 것
- 스프링 빈의 이벤트 라이프사이클
    - 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
- ❗[TIP 9] 객체의 생성과 초기화를 분리하자.
    - 유지보수 관점에서 더 좋다.
### 2) 인터페이스 InitializingBean, DisposableBean
- 지금은 더 나은 방법들이 있어서 잘 사용되지 않는다
- 단점
    - 스프링 전용 인터페이스이기에 스프링에 의존적이다.
    - 빈에 등록이 되기 때문에 코드 수정이 불가능하여 외부 라이브러리에 적용할 수 없다.
### 3) 빈 등록 초기화, 소멸 메서드
- 장점
    - 메서드 이름을 자유롭게 줄 수 있다.
    - 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.
- @Bean(destroyMethod) 속성에는 기본값이 (inferred)이기에 생략해도 close, shutdown 과 같은 종료 메서드를 자동으로 호출해준다.
### 4) 애노테이션 @PostConstruct, @PreDestroy
- 장점
    - 패키지가 `javax.annotation.*` 이므로 자바 표준이기에 스프링이 아닌 다른 컨테이너에서도 동작한다.
    - 매우 편리하고, 최신 스프링에서도 권장하므로 사용하지 않을 이유가 없다.

## 9. 빈 스코프
### 1) 빈 스코프란?
- 빈의 생존 범위
- 빈 스코프 종류
    - 싱글톤, 프로토타입, 웹 관련(request, session, application)
### 2) 프로토타입 스코프
- 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다. 즉, 요청할 때마다 새롭게 생성된다.
- 이후, 클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다.
- 프로토타입 빈의 관리 책임은 해당 빈을 받은 클라이언트에게 있다. 그래서 `@PreDestroy`와 같은 종료 메서드가 호출되지 않는다.
### 3) 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
- 싱글톤 빈에서 프로토타입 빈을 필드로 사용하게 되면, 싱글톤 빈이 DI 받을 때 프로토타입 빈을 주입받고, 계속 같은 프로토타입 빈을 괸리하게 된다.
### 4) 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결
- 해결방안 1 - 스프링 컨테이너에 요청
    - 싱글톤 빈이 프로토타입을 사용할 때마다 스프링 컨테이너에 새로 요청하는 방법
    - 스프링 컨테이너에 종속적인 코드가 되므로 단위 테스트도 어려워지므로, 사용하지 말자.
- 해결방안 2 - ObjectFactory, ObjectProvider (extends ObjectFactory)
    - 지정한 빈을 컨테이너에서 대신 찾아주는 DL(Dependency Lookup) 기능
    - 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
- 해결방안 3 - JSR-330 Provider
    - 자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
    - `javax.inject:javax.inject:1` 라이브러리를 gradle에 추가해야 하는 불편함이 있다.
- ❓ 무엇을 선택해야 할까 : Java 표준 제공 기능 vs 스프링 제공 기능
    - 애플리케이션이 스프링이 아닌 다른 컨테이너를 사용할 일이 없다면, 기능적으로 더 깔끔하게 제공해주는 것으로 그때 그때 보고 결정하자.
### 5) 웹 스코프
- 웹 환경에서만 동작하며, 스프링이 해당 스코프의 종료시점까지 관리한다.
- 종류
    - request 웹 스코프 : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
    - session 웹 스코프 : HTTP Session과 동일한 생명주기를 가지는 스코프
    - application 웹 스코프 : 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프
    - websocket 웹 스코프 : 웹 소켓과 동일한 생명주기를 가지는 스코프
### 6) request 스코프 예제 만들기
- ❗[TIP 9] 웹과 관련된 부분은 컨트롤러까지만 사용해야 한다. 서비스 계층은 웹 기술에 종속되지 않고, 가급적 순수하게 유지하는 것이 유지보수 관점에서 좋다.
- 예제 코드를 완성시켰지만, `Scope 'request' is not active ...` 오류를 맞이한다. 그 이유는 각 빈들이 생성되며 DI 받을 때, MyLogger는 request 요청이 없어서 만들어지지 않았기 때문이다.
    - 이 문제는 Provider를 적용시켜서 해결할 수 있다.
### 7) 스코프와 Provider
- MyLogger를 ObejctProvider를 사용하여 `ObjectProvider.getObject()`를 호출하는 시점까지 빈의 생성을 지연하였다.
- ❓ : ObjectProvider는 어떻게 Controller와 Service에서 각각 같은 HTTP request에 대한 빈을 가져오는 걸까?
    - HTTP Request의 attribute에 request 빈의 이름을 key로 저장하기 때문에 가능한 것
    - https://www.inflearn.com/questions/403508
### 8) 스코프와 프록시
- `@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)`를 사용한 프록시 적용
    - CGLIB가 해당 클래스를 상속받은 가짜 프록시 객체를 만들어서 주입한다.
    - 가짜 프록시 객체는 요청이 오면, 그때 내부에서 진짜 빈을 요청하는 위임 로직을 실행한다.
- 프록시 객체 덕분에 편리하게 request scope를 사용할 수 있다.
- 그러나 무분별하게 사용하면 테스트도, 유지보수도 어려워지므로 내부적으로 꼭 필요할 때에만 사용하자.

## 10. 다음으로
