상위 폴더의 README.md 내용을 책 목차에 따라 분류한 폴더입니다 :)
# Chapter 1~5 자바 기본 문법
## 자바 실행 구조, JVM의 역할
책 첫 챕터에 자바 실행 구조 및 JVM에 대한 설명이 있다. 자바 입문자를 염두에 두어 쓰인 책이다 보니 좀 더 내용을 보충할 수 있을 것 같아서 정리한다.
프로그램을 실행시키는데 있어 C와 자바의 차이점을 중심으로 이미지를 만들어보았다. 이미지로 비교하면 자바 실행 구조가 어떤 특징을 가지고 있는지 좀 더 명확하게 이해할 수 있을 것 같았기 때문이다.

### 실행 구조
자바를 공부하면서 C의 실행 구조를 깊이 공부할 필요는 없다. 하지만 C의 실행 구조를 알면 자바는 기존 언어와 어떤 차이점이 있는지, 자바가 환경에 독립적인 언어가 될 수 있었던 원리는 무엇인지 이해할 수 있게 된다.

어떤 프로그래밍 언어든 1)소스 코드는 2)변환 과정을 거쳐 3)특정 환경에서 실행될 수 있는 기계어가 된다. CPU나 운영체제 종류 별로 이해할 수 있는 기계어는 모두 다르다. 따라서 어떤 환경에서 실행될 수 있는 기계어는 그 환경에 맞춤되어 있는 특정 기계어여야만 한다. 자바와 C의 실행 모델 모두 컴퓨터에서 실행되기 위해 이 기계어를 만들어내는 과정이라고 볼 수 있다.

### C언어
![image](https://user-images.githubusercontent.com/76809524/184490285-62d3eec0-22ee-451c-aead-7c940a012120.png)

C의 경우 소스 코드를 컴파일러에 넣으면 특정 환경에서 바로 실행 할 수 있는 기계어로된 실행 파일이 나온다. 특정 환경용 실행 파일을 만들기 위해서는 실행 파일을 만들어주는 컴파일러 또한 그 환경 전용이어야한다.

C에서 프로그램을 배포하려면 하나의 소스코드를 여러 개의 전용 컴파일러에 넣어서 각 환경에 맞는 실행 파일들을 배포해야 한다. 실행 파일 하나로는 모든 환경을 커버할 수 없기 때문이다. 따라서 C개발자들은 환경 별로 여러 버전의 실행 파일을 만들어서 모두 배포해야 하는 번거로움을 겪는다.


### 자바, JVM의 역할
![image](https://user-images.githubusercontent.com/76809524/184490395-165b3693-077a-4034-9980-4be6bc1d69d3.png)
자바의 경우 소스 코드를 컴파일러에 넣으면 기계어 대신 바이트 코드가 나온다. 바이트 코드는 기계어가 아닌 JVM이 해석할 수 있는 범용적인 파일이다. 따라서 C와 자바의 컴파일러는 성격이 상당히 다르다.

이렇게 나온 바이트 코드는 JVM이 실행시킨다. 바이트 코드는 범용적인 파일이라 어떤 환경 전용 JVM이 든 같은 .class파일을 보고 실행시킨다. 실제로 자바 프로그램은 기계어가 아닌 .class파일을 JVM에게 해석시키는 것으로부터 시작된다. 자바는 JVM 실행 모델을 도입함으로써 바이트 코드만 배포하면 모든 환경에서 프로그램을 실행시킬 수 있는 크로스 플랫폼을 구축한 것이다.

물론  잃은 점도 있다. 컴퓨터가 프로그램을 실행하려면 기계어가 필요함으로 JVM은 바이트 코드를 기계어로 번역한다. 이 번역 과정이 실행 중에 일어나므로 C에 비해서는 속도가 느리다. C로 작성된 실행 파일의 경우 곧바로 실행될 수 있는 전체 기계어 파일이 완성되어 있기 때문이다. 하지만 최근 들어 인터프리터, JIT 최적화 기법이 발달됨에 따라 속도의 격차가 많이 줄어들었다.


---
## 기본형 vs 참조형 변수
2장에서 변수의 타입에 대해 설명하지만 기본형에 대해서만 설명하고 있다. 참조형에 대해서는 일단 다루지 않다가 한 참 후인 6장 264p에서 메서드 매개변수와 함께 설명한다.
그 때 배워도 되겠지만, 프로그래밍에서 '기본형 vs 참조형'이라는 주제가 워낙 유명한 주제인 만큼 두 타입을 비교해보는게 의미 있을 것 같아 다루어 보겠다.

### 값을 저장한 변수 vs 주소를 저장한 변수
두 변수 타입을 이해할 때 변수가 저장하고 있는 값이 무엇인지를 생각하면 이해하기 쉽다. '실제 값'을 저장하면 기본형, 다른 변수가 위치한 메모리 '주소'를 저장하면 참조형 변수이다(자바는 실제 메모리 주소 대신 JVM이 메모리 주소와 맵핑해주는 참조값을 저장하지만 이 또한 주소와 비슷한 개념이다).


![image](https://user-images.githubusercontent.com/76809524/184539874-d969833e-0bc0-42cb-939b-8f1415be3aa6.png)

<div style="text-align: right"> (대충 만듬) </div>




위 그림을 보면 스택 메모리 안에 int형 변수, float형 변수, Person 형 변수가 있다. 어떤 함수 안에서 변수를 선언하면 그 변수는 타입에 상관없이 항상 스택에 저장된다. Int나 float 같은 기본형은 스택에 변수의 값이 곧바로 저장되고, Person같은 참조형(클래스형)은 스택에 Person의 데이터들을 저장한 곳을 가르키는 주소값이 저장된다.

그렇다면 실제 Person의 데이터(멤버 변수 등)는 어디에 저장되었을까? Person 객체의 데이터는 힙 메모리에 저장된다. 우리가 객체를 만들 때 'new' 라는 키워드를 쓰는데 이 키워드는 힙 메모리에서 새로운 공간을 할당 받겠다는 의미이다.  
'new' 키워드로 힙 메모리를 할당 받아 Person객체의 데이터를 저장하고 그 힙 메모리의 주소를 스택의 Person형 변수로 참조하는 것이다.

### 값에 의한 호출 vs 참조에 의한 호출
함수에 매개변수를 넘길 때 매개변수 타입에 따라 **'값에 의한 호출'**,  **'참조에 의한 호출'** 로 나누곤 한다.  일반적으로 이 개념을 학습할 때 '기본형은 값이 복사되어서 넘어가며, 참조형은 원본이 넘어간다'고 배우는데 값형과 참조형의 차이를 안다면 **이렇게 나눠서 이해할 필요가 없다**. 매개변수가 저장하고 있는 값이 무엇인지를 생각하면 이해하기 쉽다.

값형은 '실제 값'을 가지고 있고, 참조형은 '주소 값'을 가지고 있다. 따라서 값형 매개변수는 값을 복사해서 넘어가고, 참조형 매개변수는 주소를 복사해서 넘어간다. 두 매개변수 모두 매개변수 값이 복사되어 함수로 넘어간다는 점은 동일하다. 하지만 참조형의 경우 복사되는 값이 주소 값이므로 함수 안에서 힙 메모리의 객체 데이터에 접근할 수 있다(객체의 주소를 알기 때문). 이 때문에 참조형 매개변수는 원본이 넘어간 것처럼(?) 보이는 것이다.

'참조에 의한 호출'을 변수 원본이 넘어가는 것으로 이해해도 코딩할 때 불편함이 없다면 아무 상관없다. 하지만 참조형 안에 또 참조형 변수가 있어서 참조가 꼬리를 물고 여러 번 이어질 때 헷갈려하는 모습을 종종 봤다. 참조가 여러 번 이어질 때 참조형 변수들이 들어있는 배열 등을 참조하고 있으면 더욱 헷갈릴 수 있다. 따라서 변수 타입이나, 매개변수 전달에 대해서 좀 더 명확하게 이해하고 싶다면 위 같은 시각으로도 접근해보는 것을 추천한다.
