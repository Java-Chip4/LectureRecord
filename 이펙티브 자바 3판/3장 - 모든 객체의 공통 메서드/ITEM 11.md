# ITEM 11. equals를 재정의하려거든 hashCode도 재정의하라

아이템 11에 따르면 equals를 재정의한 클래스라면 hashCode도 재정의해야 한다.  
그 이유는 무엇일까?

답을 찾기 위해 equals() 메서드는 재정의 되어있고, hashCode는 재정의되지 않는 상황을 대해 생각해보자.


## 문제
이펙티브 자바 책의 예시들을 문제로 재구성해보았다.  
PhoneNumber클래스에 equals()가 재정의 되어있으나, hashCode()는 재정의 되어있지 않은 상황이다.  
재정의 된 equals()가 두 객체를 같다고 판단했는데(true반환), hashCode()는 재정의 되어있지 않아서 두 객체가 다른 hashcode를 반환하면 어떻게 될까?

```
//PhoneNumber를 키로 하는 해시맵을 만들었다.
Map<PhoneNumber, String> map = new HashMap();

//new PhoneNumber(707, 867, 5309) 객체를 해시맵에 등록한다.
map.put(new PhoneNumber(707, 867, 5309), "제니");

//new PhoneNumber(707, 867, 5309) 객체 키로 해시맵에서 조회한다.
String isJenny = map.get(new PhoneNumber(707, 867, 5309);

isJenny에는 어떤 값이 들어있을까요? -> (스터디 시간에 맞춰보기)
```
### 힌트
```
 hashMap.get() 의 원리
 if (두 key 객체가 반환한 hashCode값이 같은지 비교 && 두 key 객체를 equals 메서드로 비교) {
    ///반환
}
```

## 메서드 재정의에 관해 참고할만한 규약
### Object 클래스 API문서에 기술된 메서드 규약

1. **equals()가 두 객체를 같다고 판단했다면, 두 객체의 hashCode()는 똑같은 값을
   반환해야 한다.**


위 예제의 상황을 방지하기 위함!  
재정의 되지 않은 hashCode()는 물리적으로 다른 객체(서로 다른 메모리에 위치한 두 객체)에 대해 다른 hashCode를 반환한다.  
'물리적으로 다른 두 객체'를 '논리적으로 같은' 두 객체로 취급하기 위해 equals 메서드를 재정의했다면 hashCode()메서드 또한 재정의해야한다.

2. **equals() 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그
   객체의 hashCode() 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.
   단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.**

이 규약이 지켜지는 이유는 변경되지 않은 equals 메서드는 비교에 '메모리 주소'를 사용하기 때문.

몇 번을 호출해도 객체의 메모리 주소가 변하지 않기에 같은 해시코드를 반환한다.

애플리케이션이 다시 실행되면 객체의 메모리 위치도 변화함으로 이 값은 달라진다. -> (기본 함수의 해시코드 저장 X, 의존 X)

3. **equals()가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode()가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블
   의 성능이 좋아진다.**  
   equals()가 두 객체를 다르다고 판단했을 때, 두 객체의 hashCode()가 같은 값을 반환하더라도 HashMap 키로 해당 클래스를 써도 된다.  
   해시맵을 쓰는데 기능적인 문제는 생기지 않으며 해시 충돌 가능성이 높아져서 성능이 떨어질 뿐이다. 위에 제시한 문제의 힌트를 참조하면 왜 문제가 생기지 않는지 알 수 있다.



## 두 메서드를 쓰는 상황 정리
equals()와 hashCode()를 쓸 때 바람직한 상황 3가지에 대한 정리이다.

![프레젠테이션1](https://user-images.githubusercontent.com/76809524/203526983-f441fcdc-214a-4272-8c88-4568904c47f6.jpg)
